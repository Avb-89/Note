
## === Установка ===
 For Ubuntu - `$ sudo apt-get install git`

 For Mac - Он предустановлен, если не ошибка:
 xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun
 то:
  # xcode-select --install

## === Настройка ===
`$ git config  user.name "My Name"`

`$ git config  user.email myEmail@example.com`

    #Git хранит весь пакет конфигураций в файле .gitconfig, находящемся в вашем локальном каталоге. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам, необходимо добавить флаг –-global.

`$ git config --list`

    #посмотреть все настройки системы

`$ git config color.ui true`

`$ git config color.status auto`

`$ git config color.branch auto`

    #Для удобства и легкости зрительного восприятия, некоторые группы команд в Гит можно выделить цветом (для применимыми ко всем проектам --global)

## === Создание нового репозитория ===

    #git хранит свои файлы и историю прямо в папке проекта
    в  .git, будет храниться история репозитория и настройки

`$ mkdir Desktop/git_exercise/ ` - создаем папку

`$ cd Desktop/git_exercise/ ` - заходим в нее

`$ git init ` - инициирукм git репозиторий

## === Определение состояния ===

`$ git status`

    #показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее.

## === Подготовка файлов ===

`$ git add hello.txt` - добавить один файл

`$ git add -A` - добавить все файлы в проэкте

    # Конечно добавлять всё сразу удобнее, чем прописывать каждую позицию отдельно. Однако, тут надо быть внимательным, чтобы не добавить по ошибке ненужные элементы. Если же такое произошло изъять оттуда ошибочный файл можно при помощи команды git reset:

`$ git reset . ` - все файлы

`$ git reset css/style.css` - определенный файл

    # создадим непосредственно сам коммит

`$ git commit -m 'Add some code' ` 

    # Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»

## === Как посмотреть коммиты ===

`$ git log`
 $ git log --oneline - показать в удобном виде
`$ git show hash_commit `

    #Чтобы увидеть разницу между двумя коммитами, используется команда diff (с указанием промежутка между коммитами)

`$ git diff hash_commit `

    #переделать commit message и внести туда новый комментарий

`$ git commit --amend -m 'Новый комментарий'`

    #### WARNING!!!!! В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит,
    поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер

## === Возвращение файла к предыдущему состоянию ===

`$ git checkout hash_commit hello.txt`

## === Исправление коммита ===

    # Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.
    Самый последний коммит может быть доступен по алиасу HEAD

`$ git revert HEAD`

    # Для остальных будем использовать идентификаторы:

`$ git revert hash_commit`

## === Удаленные репозитории ===
    #Сейчас наш коммит является локальным — существует только в директории .git на нашей файловой системе

#### 1. Клонирование

`$ git clone https://github.com/tutorialzine/awesome-project` - чтобы скачать только содержимое папки, добавим в конец "." или указать название папки "my_folder"

#### 2. Подключение к удаленному репозиторию

`$ git remote add origin https://gitlab.autostat.ru/bugakov/FNP_app.git`

    # Проект может иметь несколько удаленных репозиториев одновременно. Чтобы их различать, мы дадим им разные имена. Обычно главный репозиторий называется origin.

#### 3. Отправка изменений на сервер

`$ git push origin master`

    #Эта команда немного похожа на git fetch, с той лишь разницей, что при помощи fetch мы импортируем коммиты в локальную ветку, а при применив push, мы экспортируем их из локальной в удаленную

    git push - командой выгрузки,
    git pull и git fetch - командами загрузки или скачивания

#### 4. Запрос изменений с сервера

`$ git pull origin master`

## === Как удалить локальный репозиторий ===

    # Чтобы удалить репозиторий у себя на компьютере, надо удалить папку .git в папке проэкта

`$ cd repository-path/`

`rm -r .git`

## === Ветвление ===

    # Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:

    - Уже рабочая, стабильная версия кода сохраняется.
    - Различные новые функции могут разрабатываться параллельно разными программистами.
    - Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
    - В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.

#### 1. Создание новой ветки

`$ git branch new_branch`

#### 2. Переключение между ветками

`$ git branch` - отобразить какие ветки есть в репозитории (проэкте)

`$ git checkout new_branch`

#### 3. Слияние веток
    # При слиянии веток второстепенная ветка никуда не исчезает, просто изменения из одной ветки переносятся в другую (выглядит как синхранизация)

    # сначала нужно переключиться на ветку в ветку в которую мерджим

`$ git checkout master`

`$ git merge new_branch`

    # Если хотите создать копию удаленного репозитория - используйте git clone. Однако если вам нужна только определенная его ветка, а не все хранилище - после git clone выполните 

`git checkout -b <имя ветки> origin/<имя ветки>` - После этого, новая ветка создается на машине автоматически.

## === Как удалять ветки в Git? ===

    # Чтобы удалить ненужную(смерженую) ветку, не забываем переключиться на другую ветку например master

`$ git branch -d new_branch`


Команда git grep позволяет искать в истории коммитов или в рабочем каталоге по строке или
регулярному выражению.
# Возьмем произвольный (по моему выбору) репозиторий
git clone git@github.com:dagger/dagger.git
# Вывести файлы и номера строк
git grep -n/--line-number jenkins
# Только имена файлов
git grep -l/--name-only jenkins
# Вывести файлы и счетчик совпадений
git grep --count jenkins
Если вас интересует контекст строки поиска:
# Показать метод или функцию, в котором присутствует совпадение
git grep -p/--show-function jenkins
# Поиск с условиями и в более читаемом виде
git grep --break --heading -n -e jenkins --and \( -e AWS_ACCESS -e AWS_SECRET \) v0.2.0
git grep --break --heading -n -e jenkins --and \( -e AWS_ACCESS -e AWS_SECRET \) v0.2.7

Журнал ссылок
Одна из вещей, которую Git делает в фоновом режиме, является ведение журнала ссылок, в котором сохраняется то, куда указывали HEAD и ветки за последние несколько месяцев.
# Для просмотра этого журнала используется команда git reflog
git reflog
# Например, чтобы посмотреть, куда ссылался указатель HEAD пять шагов назад, используйте ссылку @{5}
git show HEAD@{5}
Такой способ работает только для данных, которые всё ещё содержатся в вашем журнале ссылок, поэтому вы не можете использовать её для коммитов, которые старше нескольких месяцев.
# чтобы увидеть где была ветка master вчера
git show master@{yesterday}
Ещё один популярный способ указать коммит — это использовать его родословную. Если вы поместите ^ в конце ссылки, Git поймёт, что вам нужен родитель этого коммита. Для просмотра предыдущего коммита достаточно написать HEAD^, что означает «родитель HEAD». Можно дополнить номером. ^2 означает «второй родитель HEAD».
Такой синтаксис полезен только для коммитов слияния, которые имеют больше одного родителя. Первым родителем является ветка, в которую вы выполняли слияние, а вторым — коммит в ветке, которую вы сливали. В Windows символ ^ нужно экранировать
# Просмотра предыдущего коммита
git show HEAD^
Другой важный символ: тильда ~. Он также соответствует ссылке на первого родителя, поэтому HEAD~ и HEAD^ эквивалентны. Различия становятся заметными, когда вы указываете число. HEAD~2 означает «первый родитель первого родителя» или «дедушка»
# Посмотреть на прадедушку, можно использовать HEAD~~~ git show HEAD~3

Восстановление данных
В какой-то момент при работе с Git вы можете нечаянно потерять коммит.
Ниже приведён пример, в котором мы сбрасываем ветку master с потерей данных до более раннего состояния, а затем восстанавливаем потерянные коммиты. Для выполнения задания нужна ветка с несколькими коммитами.
# Посмотреть, как сейчас выглядит история изменений
git log --pretty=oneline
# Теперь сбросим ветку master на третий коммит
git reset --hard <sha>
Теперь два последних коммита по-настоящему потеряны — они не достижимы ни из одной ветки. Необходимо найти SHA-1 хеш последнего коммита и создать ветку, указывающую на него. Сложность в том, чтобы узнать этот самый SHA-1, ведь вряд ли вы его запомнили (не подглядывать! )
# Самый быстрый способ посмотреть где находился HEAD в любой момент времени
git reflog
# Здесь мы видим два коммита, на которые когда-то указывал HEAD, однако информации не так уж и много. Для получения информации в более удобном виде, можно воспользоваться командой, которая выведет лог записей из reflog в привычном формате
git log -g
# Коммит, который потеряли, можно восстановить, создав новую ветку, указывающую на него
git branch recover-branch <sha>
git log --oneline recover-branch
Теперь у нас есть ветка recover-branch, указывающая туда, куда ранее указывала ветка master, тем самым делая потерянные коммиты вновь доступными.
Другой вариант поиска потеряшек — использование утилиты git fsck, проверяющей внутреннюю базу данных на целостность. Если выполнить её с ключом --full, будут показаны все объекты, недостижимые из других объектов
# Потерянный коммит будет указан после слов «dangling commit» («висячий коммит»)
git fsck --full


